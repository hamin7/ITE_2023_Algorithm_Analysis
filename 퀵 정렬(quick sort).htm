<!DOCTYPE html>
<!-- saved from url=(0065)https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[알고리즘] 퀵 정렬(quick sort)이란 - Heee's Development Blog</title>
    <meta name="author" content="HeeJeong Kwon">
    <meta name="description" content="[알고리즘] 퀵 정렬(quick sort)이란">
    <meta name="keywords" content="algorithm, 퀵정렬, sort">
    <!-- Open Graph -->
    <meta property="og:title" content="[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog">
    <meta property="og:type" content="website">
    <meta property="og:url" content="http://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html">
    <meta property="og:description" content="Step by step goes a long way.">
    <meta property="og:site_name" content="Heee&#39;s Development Blog">
    <link rel="stylesheet" href="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/normalize.min.css">
    <link rel="stylesheet" href="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/font_roc50gemkxpw4s4i.css">
    <link rel="stylesheet" href="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/github-markdown.css">
    <link rel="stylesheet" href="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/prism.css">
    <link rel="stylesheet" href="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/share.min.css">
    <link rel="stylesheet" href="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/app.min.css">
    <link rel="shortcut icon" href="https://gmlwjd9405.github.io/assets/img/penguin2.ico">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script src="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/f.txt"></script><script type="text/javascript" async="" src="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/analytics.js"></script><script src="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/ca-pub-2537250461183662.js"></script><script async="" src="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/js"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-108900430-2');
    </script>
<link rel="preload" href="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/f(1).txt" as="script"><script type="text/javascript" src="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/f(1).txt"></script><link rel="preload" href="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/f(2).txt" as="script"><script type="text/javascript" src="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/f(2).txt"></script><script src="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/embed.js" data-timestamp="1539676309664"></script><script src="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/embed.js" data-timestamp="1539676309706"></script><link rel="preload" as="style" href="https://c.disquscdn.com/next/embed/styles/lounge.a23d3336e8b7e07b2d7d087a82db3283.css"><link rel="preload" as="script" href="https://c.disquscdn.com/next/embed/common.bundle.18932c85febf9520158697cdc31f08ae.js"><link rel="preload" as="script" href="https://c.disquscdn.com/next/embed/lounge.bundle.cc61696b051d0ab202a6e9f6041f40df.js"><link rel="preload" as="script" href="https://disqus.com/next/config.js"><link rel="preload" as="style" href="https://c.disquscdn.com/next/embed/styles/lounge.a23d3336e8b7e07b2d7d087a82db3283.css"><link rel="preload" as="script" href="https://c.disquscdn.com/next/embed/common.bundle.18932c85febf9520158697cdc31f08ae.js"><link rel="preload" as="script" href="https://c.disquscdn.com/next/embed/lounge.bundle.cc61696b051d0ab202a6e9f6041f40df.js"><link rel="preload" as="script" href="https://disqus.com/next/config.js"><script src="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/alfalfa.4a5fcca1fe50a757044dfd331b660625.js" async="" charset="UTF-8"></script></head>

<body>
    <!--[if lt IE 10]>
<div class="alert-danger" role="alert">你的浏览器实在太太太旧了，放学别走，升级完浏览器再说！<a target="_blank" class="alert-link" href="http://browsehappy.com">立即升级</a></div>
<![endif]-->
 <input id="nm-switch" type="hidden" value="false">

<header class="g-header headerUp headerDown" style="background-color: rgba(255, 255, 255, 0.98); box-shadow: rgba(0, 0, 0, 0.08) 0px 1px 12px;">
  <!--
    <div class="g-logo">
        <a href=""></a>
    </div>
  -->
    <i id="menu-toggle" class="iconfont icon-menu"></i>
    <nav class="g-nav nav-default">
        <ul>
            
            <li><a href="https://gmlwjd9405.github.io/" style="color: rgb(102, 102, 102);">home</a></li>
            
            <li><a href="https://gmlwjd9405.github.io/tags.html" style="color: rgb(102, 102, 102);">tags</a></li>
            
        </ul>
    </nav>
</header>


<header class="g-banner post-header post-pattern-circuitBoard bgcolor-default " data-theme="default">
    <div class="post-wrapper">
        <div class="post-tags">
            
            
            <a href="https://gmlwjd9405.github.io/tags#algorithm" class="post-tag">algorithm</a>
            
            <a href="https://gmlwjd9405.github.io/tags#%ED%80%B5%EC%A0%95%EB%A0%AC" class="post-tag">퀵정렬</a>
            
            <a href="https://gmlwjd9405.github.io/tags#sort" class="post-tag">sort</a>
            
            
        </div>
        <h1>[알고리즘] 퀵 정렬(quick sort)이란</h1>
        <div class="post-meta">
            <span class="post-meta-item"><i class="iconfont icon-author"></i><a href="http://gmlwjd9405.github.io/" target="_blank" rel="author">heejeong Kwon</a></span>
            <time class="post-meta-item" datetime="18-05-10"><i class="iconfont icon-date"></i>10 May 2018</time>
        </div>
    </div>
    
    <div class="filter"></div>
    <div class="post-cover" style="background: url(&#39;/images/algorithm-quick-sort/algorithm-quick-sort-main2.png&#39;) center no-repeat; background-size: cover;">
    
</div></header>

<div align="center">

<script async="" src="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/f(3).txt"></script>
<!-- PC_Bottom_auto -->
<ins class="adsbygoogle" style="display: block; margin-top: 10px; height: 90px;" data-ad-client="ca-pub-2537250461183662" data-ad-slot="3651407657" data-ad-format="auto" data-adsbygoogle-status="done"><ins id="aswift_0_expand" style="display:inline-table;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:803px;background-color:transparent;"><ins id="aswift_0_anchor" style="display:block;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:803px;background-color:transparent;"><iframe width="803" height="90" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_0" name="aswift_0" style="left:0;position:absolute;top:0;width:803px;height:90px;" src="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/saved_resource.html"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

</div>


<div class="post-content">
    
    <h2 class="post-subtitle">분할 정복 알고리즘의 하나, 평균적으로 매우 빠른 수행 속도를 자랑하는 정렬 방법</h2>
    
    <article class="markdown-body">
        <h2 id="goal">Goal</h2>
<blockquote>
  <ul>
    <li>퀵 정렬(quick sort) 알고리즘을 이해한다.
<!-- > - 퀵 정렬(quick sort) 알고리즘을 java와 c언어로 구현한다. --></li>
    <li>퀵 정렬(quick sort) 알고리즘을 c언어로 구현한다.</li>
    <li>퀵 정렬(quick sort) 알고리즘의 특징</li>
    <li>퀵 정렬(quick sort) 알고리즘의 시간복잡도를 이해한다.</li>
  </ul>
</blockquote>

<p>들어가기 전</p>
<ul>
  <li>오름차순을 기준으로 정렬한다.</li>
</ul>

<h2 id="퀵-정렬quick-sort-알고리즘의-개념-요약">퀵 정렬(quick sort) 알고리즘의 개념 요약</h2>
<ul>
  <li>‘찰스 앤터니 리처드 호어(Charles Antony Richard Hoare)’가 개발한 정렬 알고리즘</li>
  <li>퀵 정렬은 <strong>불안정 정렬</strong> 에 속하며, 다른 원소와의 비교만으로 정렬을 수행하는 <strong>비교 정렬</strong> 에 속한다.</li>
  <li>분할 정복 알고리즘의 하나로, 평균적으로 <span style="color:#4d0000"><strong>매우 빠른 수행 속도를</strong></span> 자랑하는 정렬 방법
    <ul>
      <li>합병 정렬(merge sort)과 달리 퀵 정렬은 리스트를 <strong>비균등하게</strong> 분할한다.</li>
    </ul>
  </li>
  <li>분할 정복(divide and conquer) 방법
    <ul>
      <li>문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략이다.</li>
      <li>분할 정복 방법은 대개 순환 호출을 이용하여 구현한다.</li>
    </ul>
  </li>
  <li>과정 설명
    <ol>
      <li>리스트 안에 있는 한 요소를 선택한다. 이렇게 고른 원소를 <span style="color:#4d0000"><strong>피벗(pivot)</strong></span> 이라고 한다.</li>
      <li>피벗을 기준으로 피벗보다 작은 요소들은 모두 피벗의 왼쪽으로 옮겨지고 피벗보다 큰 요소들은 모두 피벗의 오른쪽으로 옮겨진다. (피벗을 중심으로 왼쪽: 피벗보다 작은 요소들, 오른쪽: 피벗보다 큰 요소들)</li>
      <li>피벗을 제외한 왼쪽 리스트와 오른쪽 리스트를 다시 정렬한다.
        <ul>
          <li>분할된 부분 리스트에 대하여 <strong>순환 호출</strong> 을 이용하여 정렬을 반복한다.</li>
          <li>부분 리스트에서도 다시 피벗을 정하고 피벗을 기준으로 2개의 부분 리스트로 나누는 과정을 반복한다.</li>
        </ul>
      </li>
      <li>부분 리스트들이 더 이상 분할이 불가능할 때까지 반복한다.
        <ul>
          <li>리스트의 크기가 0이나 1이 될 때까지 반복한다.</li>
        </ul>
      </li>
    </ol>
  </li>
  <li><img src="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/quick-sort-concepts.png" alt="" width="350" height="370"></li>
</ul>

<h2 id="퀵-정렬quick-sort-알고리즘의-구체적인-개념">퀵 정렬(quick sort) 알고리즘의 구체적인 개념</h2>
<ul>
  <li>하나의 리스트를 피벗(pivot)을 기준으로 두 개의 비균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법이다.</li>
  <li>퀵 정렬은 다음의 단계들로 이루어진다.
    <ul>
      <li><strong>분할(Divide):</strong> 입력 배열을 피벗을 기준으로 비균등하게 2개의 부분 배열(피벗을 중심으로 왼쪽: 피벗보다 작은 요소들, 오른쪽: 피벗보다 큰 요소들)로 분할한다.</li>
      <li><strong>정복(Conquer):</strong> 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 <strong>순환 호출</strong> 을 이용하여 다시 분할 정복 방법을 적용한다.</li>
      <li><strong>결합(Combine):</strong> 정렬된 부분 배열들을 하나의 배열에 합병한다.</li>
      <li>순환 호출이 한번 진행될 때마다 최소한 하나의 원소(피벗)는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장할 수 있다.</li>
    </ul>
  </li>
  <li><img src="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/quick-sort.png" alt="" width="430" height="650"></li>
</ul>

<h2 id="퀵-정렬quick-sort-알고리즘의-예제">퀵 정렬(quick sort) 알고리즘의 예제</h2>
<ul>
  <li>배열에 5, 3, 8, 4, 9, 1, 6, 2, 7이 저장되어 있다고 가정하고 자료를 오름차순으로 정렬해 보자.</li>
  <li><em>퀵 정렬에서 피벗을 기준으로 두 개의 리스트로 나누는 과정(c언어 코드의 partition 함수의 내용)</em></li>
  <li>
    <p><img src="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/quick-sort2.png" alt=""></p>
  </li>
  <li>피벗 값을 입력 리스트의 첫 번째 데이터로 하자. (다른 임의의 값이어도 상관없다.)</li>
  <li>2개의 인덱스 변수(low, high)를 이용해서 리스트를 두 개의 부분 리스트로 나눈다.</li>
  <li>1회전: 피벗이 5인 경우,
    <ol>
      <li>low는 왼쪽에서 오른쪽으로 탐색해가다가 피벗보다 큰 데이터(8)을 찾으면 멈춘다.</li>
      <li>high는 오른쪽에서 왼쪽으로 탐색해가다가 피벗보다 작은 데이터(2)를 찾으면 멈춘다.</li>
      <li>low와 high가 가리키는 두 데이터를 서로 교환한다.</li>
      <li>이 탐색-교환 과정은 low와 high가 엇갈릴 때까지 반복한다.</li>
    </ol>
  </li>
  <li>2회전: 피벗(1회전의 왼쪽 부분리스트의 첫 번째 데이터)이 1인 경우,
    <ul>
      <li>위와 동일한 방법으로 반복한다.</li>
    </ul>
  </li>
  <li>3회전: 피벗(1회전의 오른쪽 부분리스트의 첫 번째 데이터)이 9인 경우,
    <ul>
      <li>위와 동일한 방법으로 반복한다.</li>
    </ul>
  </li>
</ul>

<!-- ## 퀵 정렬(quick sort) java 코드
~~~javascript

~~~ -->

<h2 id="퀵-정렬quick-sort-c언어-코드">퀵 정렬(quick sort) c언어 코드</h2>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight language-javascript"><code class=" language-javascript"># include <span class="token operator">&lt;</span>stdio<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>
# define MAX_SIZE <span class="token number">9</span>
# define <span class="token function">SWAP</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> temp<span class="token punctuation">)</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span> <span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">// 1. 피벗을 기준으로 2개의 부분 리스트로 나눈다.</span>
<span class="token comment" spellcheck="true">// 2. 피벗보다 작은 값은 모두 왼쪽 부분 리스트로, 큰 값은 오른쪽 부분 리스트로 옮긴다.</span>
<span class="token comment" spellcheck="true">/* 2개의 비균등 배열 list[left...pivot-1]와 list[pivot+1...right]의 합병 과정 */</span>
<span class="token comment" spellcheck="true">/* (실제로 숫자들이 정렬되는 과정) */</span>
int <span class="token function">partition</span><span class="token punctuation">(</span>int list<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> int left<span class="token punctuation">,</span> int right<span class="token punctuation">)</span><span class="token punctuation">{</span>
  int pivot<span class="token punctuation">,</span> temp<span class="token punctuation">;</span>
  int low<span class="token punctuation">,</span> high<span class="token punctuation">;</span>

  low <span class="token operator">=</span> left<span class="token punctuation">;</span>
  high <span class="token operator">=</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
  pivot <span class="token operator">=</span> list<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 정렬할 리스트의 가장 왼쪽 데이터를 피벗으로 선택(임의의 값을 피벗으로 선택)</span>

  <span class="token comment" spellcheck="true">/* low와 high가 교차할 때까지 반복(low&lt;high) */</span>
  <span class="token keyword">do</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/* list[low]가 피벗보다 작으면 계속 low를 증가 */</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
      low<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// low는 left+1 에서 시작</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>low<span class="token operator">&lt;=</span>right <span class="token operator">&amp;&amp;</span> list<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token operator">&lt;</span>pivot<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* list[high]가 피벗보다 크면 계속 high를 감소 */</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
      high<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//high는 right 에서 시작</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>high<span class="token operator">&gt;=</span>left <span class="token operator">&amp;&amp;</span> list<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token operator">&gt;</span>pivot<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 만약 low와 high가 교차하지 않았으면 list[low]를 list[high] 교환</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token function">SWAP</span><span class="token punctuation">(</span>list<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// low와 high가 교차했으면 반복문을 빠져나와 list[left]와 list[high]를 교환</span>
  <span class="token function">SWAP</span><span class="token punctuation">(</span>list<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 피벗의 위치인 high를 반환</span>
  <span class="token keyword">return</span> high<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 퀵 정렬</span>
<span class="token keyword">void</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>int list<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> int left<span class="token punctuation">,</span> int right<span class="token punctuation">)</span><span class="token punctuation">{</span>

  <span class="token comment" spellcheck="true">/* 정렬할 범위가 2개 이상의 데이터이면(리스트의 크기가 0이나 1이 아니면) */</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// partition 함수를 호출하여 피벗을 기준으로 리스트를 비균등 분할 -분할(Divide)</span>
    int q <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// q: 피벗의 위치</span>

    <span class="token comment" spellcheck="true">// 피벗은 제외한 2개의 부분 리스트를 대상으로 순환 호출</span>
    <span class="token function">quick_sort</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> left<span class="token punctuation">,</span> q<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// (left ~ 피벗 바로 앞) 앞쪽 부분 리스트 정렬 -정복(Conquer)</span>
    <span class="token function">quick_sort</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> q<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// (피벗 바로 뒤 ~ right) 뒤쪽 부분 리스트 정렬 -정복(Conquer)</span>
  <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  int i<span class="token punctuation">;</span>
  int n <span class="token operator">=</span> MAX_SIZE<span class="token punctuation">;</span>
  int list<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 퀵 정렬 수행(left: 배열의 시작 = 0, right: 배열의 끝 = 8)</span>
  <span class="token function">quick_sort</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 정렬 결과 출력</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></div>

<h2 id="퀵-정렬quick-sort-알고리즘의-특징">퀵 정렬(quick sort) 알고리즘의 특징</h2>
<ul>
  <li>장점
    <ol>
      <li>속도가 빠르다.
        <ul>
          <li>시간 복잡도가 O(nlog₂n)를 가지는 다른 정렬 알고리즘과 비교했을 때도 가장 빠르다.</li>
        </ul>
      </li>
      <li>추가 메모리 공간을 필요로 하지 않는다.
        <ul>
          <li>퀵 정렬은 O(log n)만큼의 메모리를 필요로 한다.</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>단점
    <ol>
      <li>정렬된 리스트에 대해서는 퀵 정렬의 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다.</li>
    </ol>
  </li>
  <li>퀵 정렬의 불균형 분할을 방지하기 위하여 피벗을 선택할 때 더욱 리스트를 균등하게 분할할 수 있는 데이터를 선택한다.
    <ul>
      <li>EX) 리스트 내의 몇 개의 데이터 중에서 크기순으로 중간 값(medium)을 피벗으로 선택한다.</li>
    </ul>
  </li>
</ul>

<h2 id="퀵-정렬quick-sort의-시간복잡도">퀵 정렬(quick sort)의 시간복잡도</h2>
<ul>
  <li>최선의 경우
    <ul>
      <li>비교 횟수
        <ul>
          <li><img src="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/sort-time-complexity-etc1.png" alt=""></li>
          <li><em>순환 호출의 깊이</em>
            <ul>
              <li>레코드의 개수 n이 2의 거듭제곱이라고 가정(n=2^k)했을 때, n=2^3의 경우, 2^3 -&gt; 2^2 -&gt; 2^1 -&gt; 2^0 순으로 줄어들어 순환 호출의 깊이가 3임을 알 수 있다. 이것을 <strong>일반화하면</strong> n=2^k의 경우, k(k=log₂n)임을 알 수 있다.</li>
              <li>k=log₂n</li>
            </ul>
          </li>
          <li><em>각 순환 호출 단계의 비교 연산</em>
            <ul>
              <li>각 순환 호출에서는 전체 리스트의 대부분의 레코드를 비교해야 하므로 평균 n번 정도의 비교가 이루어진다.</li>
              <li>평균 n번</li>
            </ul>
          </li>
          <li>순환 호출의 깊이 * 각 순환 호출 단계의 비교 연산 = <strong>nlog₂n</strong></li>
        </ul>
      </li>
      <li>이동 횟수
        <ul>
          <li>비교 횟수보다 적으므로 무시할 수 있다.</li>
        </ul>
      </li>
      <li>최선의 경우 T(n) = <strong>O(nlog₂n)</strong></li>
    </ul>
  </li>
  <li>최악의 경우
    <ul>
      <li>리스트가 계속 불균형하게 나누어지는 경우 (특히, 이미 정렬된 리스트에 대하여 퀵 정렬을 실행하는 경우)</li>
      <li><img src="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/sort-time-complexity-etc2.png" alt="" width="350" height="280"></li>
      <li>비교 횟수
        <ul>
          <li><em>순환 호출의 깊이</em>
            <ul>
              <li>레코드의 개수 n이 2의 거듭제곱이라고 가정(n=2^k)했을 때, 순환 호출의 깊이는 n임을 알 수 있다.</li>
              <li>n</li>
            </ul>
          </li>
          <li><em>각 순환 호출 단계의 비교 연산</em>
            <ul>
              <li>각 순환 호출에서는 전체 리스트의 대부분의 레코드를 비교해야 하므로 평균 n번 정도의 비교가 이루어진다.</li>
              <li>평균 n번</li>
            </ul>
          </li>
          <li>순환 호출의 깊이 * 각 순환 호출 단계의 비교 연산 = <strong>n^2</strong></li>
        </ul>
      </li>
      <li>이동 횟수
        <ul>
          <li>비교 횟수보다 적으므로 무시할 수 있다.</li>
        </ul>
      </li>
      <li>최악의 경우 T(n) = <strong>O(n^2)</strong></li>
    </ul>
  </li>
  <li>평균
    <ul>
      <li>평균 T(n) = <strong>O(nlog₂n)</strong></li>
      <li>시간 복잡도가 O(nlog₂n)를 가지는 다른 정렬 알고리즘과 비교했을 때도 가장 빠르다.</li>
      <li>퀵 정렬이 불필요한 데이터의 이동을 줄이고 먼 거리의 데이터를 교환할 뿐만 아니라, 한 번 결정된 피벗들이 추후 연산에서 제외되는 특성 때문이다.</li>
    </ul>
  </li>
</ul>

<h1 id="정렬-알고리즘-시간복잡도-비교">정렬 알고리즘 시간복잡도 비교</h1>
<p><img src="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/sort-time-complexity.png" alt=""></p>

<ul>
  <li>단순(구현 간단)하지만 비효율적인 방법
    <ul>
      <li>삽입 정렬, 선택 정렬, 버블 정렬</li>
    </ul>
  </li>
  <li>복잡하지만 효율적인 방법
    <ul>
      <li><strong>퀵 정렬</strong>, 힙 정렬, 합병 정렬, 기수 정렬</li>
    </ul>
  </li>
</ul>

<h1 id="관련된-post">관련된 Post</h1>
<ul>
  <li>선택 정렬(selection sort): <a href="https://gmlwjd9405.github.io/2018/05/06/algorithm-selection-sort.html">선택 정렬(selection sort)</a> 을 참고하시기 바랍니다.</li>
  <li>삽입 정렬(insertion sort): <a href="https://gmlwjd9405.github.io/2018/05/06/algorithm-insertion-sort.html">삽입 정렬(insertion sort)</a> 을 참고하시기 바랍니다.</li>
  <li>버블 정렬(bubble sort): <a href="https://gmlwjd9405.github.io/2018/05/06/algorithm-bubble-sort.html">버블 정렬(bubble sort)</a> 을 참고하시기 바랍니다.</li>
  <li>셸 정렬(shell sort): <a href="https://gmlwjd9405.github.io/2018/05/08/algorithm-shell-sort.html">셸 정렬(shell sort)</a> 을 참고하시기 바랍니다.</li>
  <li>합병 정렬(merge sort): <a href="https://gmlwjd9405.github.io/2018/05/08/algorithm-merge-sort.html">합병 정렬(merge sort)</a> 을 참고하시기 바랍니다.</li>
  <li>힙 정렬(heap sort): <a href="https://gmlwjd9405.github.io/2018/05/10/algorithm-heap-sort.html">힙 정렬(heap sort)</a> 을 참고하시기 바랍니다.</li>
</ul>

<h1 id="references">References</h1>
<blockquote>
  <ul>
    <li><a href="https://ko.wikipedia.org/wiki/%ED%80%B5_%EC%A0%95%EB%A0%AC">퀵 정렬 - 위키백과</a></li>
  </ul>
</blockquote>

    </article>
    <!--
    
  -->
</div>

<div align="center">

<script async="" src="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/f(3).txt"></script>
<!-- PC_Bottom_rectangle -->
<ins class="adsbygoogle" style="display: inline-block; width: 300px; height: 250px; margin-bottom: 50px;" data-ad-client="ca-pub-2537250461183662" data-ad-slot="6843713057" data-adsbygoogle-status="done"><ins id="aswift_1_expand" style="display:inline-table;border:none;height:250px;margin:0;padding:0;position:relative;visibility:visible;width:300px;background-color:transparent;"><ins id="aswift_1_anchor" style="display:block;border:none;height:250px;margin:0;padding:0;position:relative;visibility:visible;width:300px;background-color:transparent;"><iframe width="300" height="250" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_1" name="aswift_1" style="left:0;position:absolute;top:0;width:300px;height:250px;" src="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/saved_resource(1).html"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

</div>


<section class="author-detail">
    <section class="post-footer-item author-card">
        <div class="avatar">
            <img src="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/heee.png" alt="">
        </div>
        <div class="author-name" rel="author">HeeJeong Kwon</div>
        <div class="bio">
            <p>computer programmer</p>
        </div>
        
        <ul class="sns-links">
            
            <li>
                <a href="https://github.com/gmlwjd9405" target="_blank">
                    <i class="iconfont icon-github"></i>
                </a>
            </li>
            
        </ul>
        
    </section>
    <section class="post-footer-item read-next">
        
        <div class="read-next-item">
            <a href="https://gmlwjd9405.github.io/2018/05/10/data-structure-heap.html" class="read-next-link"></a>
            <section style="margin-top: 89.5px; display: block;">
                <span>[자료구조] 힙(heap)이란</span>
                <p>Goal      우선 순위 큐를 위하여 만들어진 자료구조, 힙(heap)에 대해 이해한다.    배열...</p>
            </section>
            
            <div class="filter"></div>
            <img src="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/data-structure-heap-main.png" alt="" style="width: auto; height: 100%; margin-left: -281.047px; display: inline;">
            
        </div>
        
        
        <div class="read-next-item">
            <a href="https://gmlwjd9405.github.io/2018/05/10/algorithm-heap-sort.html" class="read-next-link"></a>
            <section style="margin-top: 75px; display: block;">
                <span>[알고리즘] 힙 정렬(heap sort)이란</span>
                <p>Goal      힙 정렬(heap sort) 알고리즘을 이해한다.    힙 정렬(heap sort) ...</p>
            </section>
            
            <div class="filter"></div>
            <img src="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/algorithm-heap-sort-main2.png" alt="" style="width: auto; height: 100%; margin-left: -239.828px; display: inline;">
            
        </div>
        
    </section>
    
    <section class="post-footer-item comment">
        <div id="disqus_thread"><iframe id="dsq-app3895" name="dsq-app3895" allowtransparency="true" frameborder="0" scrolling="no" tabindex="0" title="Disqus" sandbox="allow-forms allow-popups allow-same-origin allow-scripts" width="100%" src="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/saved_resource(2).html" style="width: 1px !important; min-width: 100% !important; border: none !important; overflow: hidden !important; height: 623px !important;"></iframe><iframe id="dsq-app3893" name="dsq-app3893" allowtransparency="true" frameborder="0" scrolling="no" tabindex="0" title="Disqus" width="100%" src="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/saved_resource(3).html" style="width: 1px !important; min-width: 100% !important; border: none !important; overflow: hidden !important; height: 1136px !important;" horizontalscrolling="no" verticalscrolling="no"></iframe><iframe id="dsq-app3897" name="dsq-app3897" allowtransparency="true" frameborder="0" scrolling="no" tabindex="0" title="Disqus" sandbox="allow-forms allow-popups allow-same-origin allow-scripts" width="100%" src="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/saved_resource(4).html" style="width: 1px !important; min-width: 100% !important; border: none !important; overflow: hidden !important; height: 203px !important;"></iframe></div>
    </section>
    
</section>

<footer class="g-footer">
    <section>Heee's Development Blog © 2018</section>
    <section>Powered by <a href="https://jekyllrb.com/">Jekyll</a></section>
</footer>


<script src="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/social-share.min.js"></script>
<script>
    socialShare('.social-share', {
        sites: [],
        wechatQrcodeTitle: "post wechatQrcodeTitle test",
        wechatQrcodeHelper: '<p>postHelper</p><p>wechatQrcodeHelper</p>'
    });
</script>

<script>
/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
/*写入自己的disqus信息*/
s.src = 'https://heees-blog.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="<a class="vglnk" href="https://disqus.com/?ref_noscript" rel="nofollow"><span>https</span><span>://</span><span>disqus</span><span>.</span><span>com</span><span>/?</span><span>ref</span><span>_</span><span>noscript</span></a>">comments powered by Disqus.</a></noscript>
<script src="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/jquery.min.js"></script>
<script src="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/prism.js"></script>
<script src="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/index.min.js"></script>


<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://heees-blog.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="<a class="vglnk" href="https://disqus.com/?ref_noscript" rel="nofollow"><span>https</span><span>://</span><span>disqus</span><span>.</span><span>com</span><span>/?</span><span>ref</span><span>_</span><span>noscript</span></a>">comments powered by Disqus.</a></noscript>





<iframe id="google_osd_static_frame_3164983501017" name="google_osd_static_frame" style="display: none; width: 0px; height: 0px;" src="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/saved_resource(5).html"></iframe><iframe style="display: none;" src="./[알고리즘] 퀵 정렬(quick sort)이란 - Heee&#39;s Development Blog_files/saved_resource(6).html"></iframe></body></html>
